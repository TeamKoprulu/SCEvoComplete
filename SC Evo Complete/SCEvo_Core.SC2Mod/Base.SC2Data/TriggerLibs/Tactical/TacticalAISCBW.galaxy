//--------------------------------------------------------------------------------------------------
//  BW Terran
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  Set Nuke Constants
//--------------------------------------------------------------------------------------------------
void BWAISetNukeConstants (int player) {
    AISetNukeGhost(player, c_BWTU_Ghost);
    AISetNukeNukeEffect(player, c_BWEF_GhostSCBWNuclearStrike_Damage);
    AISetNukeCloak(player, c_BWTR_GhostSCBWCloakResearch);
    AISetNukeNukeAbilLink(player, c_BWAB_GhostSCBWNuclearStrike);
    AISetNukeCloakAbilLink(player, c_BWAB_GhostSCBWCloak);
    
    AISetNukeCloakRegenRate(player, AIBehaviorFixed(player, c_BWBF_GhostSCBWCloak, c_fieldModification0));
    AISetNukeCloakCost(player, AIAbilityFixed(player, c_BWAB_GhostSCBWCloak, c_fieldEnergyCost));
    AISetNukeNukeCastTime(player, 20);

    AISetNukeDamage(player, AIEffectFixed(player, c_BWEF_GhostSCBWNuclearStrike_Damage, c_fieldAmount), AIEffectFixed(player, c_BWEF_GhostSCBWNuclearStrike_Damage, c_fieldAttrStructure));
    AISetNukeRadiusClose(player, AIEffectFixed(player, c_BWEF_GhostSCBWNuclearStrike_Damage, c_fieldAreaRadius0), AIEffectFixed(player, c_BWEF_GhostSCBWNuclearStrike_Damage, c_fieldAreaFraction0));
    AISetNukeRadiusMedium(player, AIEffectFixed(player, c_BWEF_GhostSCBWNuclearStrike_Damage, c_fieldAreaRadius1), AIEffectFixed(player, c_BWEF_GhostSCBWNuclearStrike_Damage, c_fieldAreaFraction1));
    AISetNukeRadiusFar(player, AIEffectFixed(player, c_BWEF_GhostSCBWNuclearStrike_Damage, c_fieldAreaRadius2), AIEffectFixed(player, c_BWEF_GhostSCBWNuclearStrike_Damage, c_fieldAreaFraction2));
}

//--------------------------------------------------------------------------------------------------
//  BWCargoDefend
//--------------------------------------------------------------------------------------------------
const fixed c_BWcampaignBunkerLoadRange = 4.0;
const bool c_BWbunkerUnload = true;
const bool c_BWbunkerLoad = false;

//---------------------------------------------------------------------------------------------
unit BWCampaignWantsToBeInBunker (int player, unit aiUnit, unitgroup bunkerGroup, bool unload) {
    int bunkerCount;
    unit unitToCheck;
    bool wantsToBeInBunker;
    order unitOrder;

    //  When loading, check to see if there is space in the bunker at all.
    //
    if (!unload) {
        if (UnitCargoValue(aiUnit, c_unitCargoSpaceFree) == 0) {
            return null;
        }
    }

    bunkerCount = UnitGroupCount(bunkerGroup, c_unitCountAll);
    while (bunkerCount > 0) {
        unitToCheck = UnitGroupUnit(bunkerGroup, bunkerCount);
        bunkerCount = bunkerCount - 1;

        //  Make sure the unit is alive.
        //
        if (!UnitIsAlive(unitToCheck)) {
            continue;
        }
        if (AIIsScriptControlled(unitToCheck)) {
            continue;
        }
        //  When loading, make sure the unit is not already in a transport.
        //
        if (!unload) {
            if (UnitTestState(unitToCheck, c_unitStateInsideTransport)) {
                continue;
            }
        }

        //  The unit wants to be somewhere far away, do not load it.
        //
        wantsToBeInBunker = true;

        if (AIControlForceToMove(unitToCheck)) {
            // If the unit is forced to move, it shouldn't be in the bunker even in combat
            wantsToBeInBunker = false;
        }
        else if (!AIUnitIsInCombat(unitToCheck) && !AIUnitIsInCombat(aiUnit)) {
            // Otherwise the unit will only want to be out of the bunker if not combat is happening
            
            //  The unit wants to execute a non attack order.
            unitOrder = UnitOrder(aiUnit, 0);
            if (unitOrder != null && !AIIsAttackOrder(unitOrder)) {
                wantsToBeInBunker = false;
            }
            //  The unit wants to move.
            else if (AIControlWantsToMove(unitToCheck)) {
                wantsToBeInBunker = false;
            }
            // Unit has no home point
            else if (AIGetHomePosition(unitToCheck) == c_nullPoint) {
                wantsToBeInBunker = false;
            }
            // Unit's home point is too far away
            else if (!PointsInRange(UnitGetPosition(aiUnit), AIGetHomePosition(unitToCheck), c_campaignBunkerLoadRange)) {
                wantsToBeInBunker = false;
            }
        }

        //  Do not care about units that want to be in bunker when we want to unload.
        //  Similarly, do not care about units that do not want to be in bunker when we want to load.
        //
        if (wantsToBeInBunker == unload) {
            continue;
        }

        return unitToCheck;
    }
    return null;
}

//---------------------------------------------------------------------------------------------
bool BWCargoDefend (int player, unit aiUnit, unitgroup scanGroup, int searchRange, int loadRange, string wanted, string command) {
    aifilter filter;
    unitgroup nearBunkerGroup;
    int bunkerCount;
    unit unitToCheck;    
    order ord = null;
    bool autoLoad = false;
    bool wantsToBeInBunker;
    unitgroup targetGroup;

    targetGroup = UnitGroupFilterRegion(scanGroup, RegionCircle(UnitGetPosition(aiUnit), searchRange), 0);
    if (UnitGroupCount(targetGroup, c_unitCountAlive) == 0) { // no nearby enemies.

        //  Both checks are needed because auto loading bunkers is needed on campaign before the
        //  AI is active.....
        if (AIIsCampaign(player)) {
            autoLoad = true;
        }
        else if (AIGetDifficulty(player, c_diffAutoLoadBunkers)) {
            autoLoad = true;
        }

        if (autoLoad && (command == c_BWAB_BunkerTransport)) {
            // handle bunkers on campaign differently.
            unitToCheck = BWCampaignWantsToBeInBunker(player, aiUnit, UnitCargoGroup(aiUnit), c_bunkerUnload);
            if (unitToCheck != null) {
                ord = AICreateOrder(player, command, e_AB_TransportUnloadUnit); // unload the bunker.
                OrderSetTargetPassenger(ord, unitToCheck);
            }

            if (ord == null) {
                nearBunkerGroup = AIFindUnits(player, wanted, UnitGetPosition(aiUnit), c_campaignBunkerLoadRange, c_noMaxCount);
                if (wanted == c_nullString) {
                    filter = AIFilter(player);
                    AISetFilterMelee(filter, c_onlyRanged);
                    AISetFilterValidPassenger(filter, aiUnit);
                    nearBunkerGroup = AIGetFilterGroup(filter, nearBunkerGroup);
                }

                unitToCheck = BWCampaignWantsToBeInBunker(player, aiUnit, nearBunkerGroup, c_bunkerLoad);
                if (unitToCheck != null) {
                    ord = AICreateOrder(player, command, e_AB_TransportLoadUnit); // load the bunker.
                    OrderSetTargetUnit(ord, unitToCheck);
                }
            }
        }
        else { // not a campaign bunker
            if (UnitCargoValue(aiUnit, c_unitCargoSpaceUsed) == 0) { // nothing to unload
                return false;
            }
            ord = AICreateOrder(player, command, e_AB_TransportUnloadAll); // unload bunker
        }
    }
    else { // nearby enemies found.
        if (UnitCargoValue(aiUnit, c_unitCargoSpaceFree) == 0) { // check for space
            return false;
        }

        if (command == c_AB_CommandCenterChange) {
            if (!AIAnyWorkersFleeingNearby(player,UnitGetPosition(aiUnit),8.0)) {
                return false;
            }
        }

        nearBunkerGroup = AIFindUnits(player, wanted, UnitGetPosition(aiUnit), loadRange, c_noMaxCount);
        if (wanted == c_nullString) {
            filter = AIFilter(player);
            AISetFilterMelee(filter, c_onlyRanged);
            AISetFilterValidPassenger(filter, aiUnit);
            nearBunkerGroup = AIGetFilterGroup(filter, nearBunkerGroup);
        }

        bunkerCount = UnitGroupCount(nearBunkerGroup, c_unitCountAll);
        while (bunkerCount > 0) {
            unitToCheck = UnitGroupUnit(nearBunkerGroup, bunkerCount);
            bunkerCount = bunkerCount - 1;

            if (!UnitIsAlive(unitToCheck)) {
                continue;
            }
            if (AIIsScriptControlled(unitToCheck)) {
                continue;
            }
            if (UnitTestState(unitToCheck, c_unitStateInsideTransport)) {
                continue;
            }
            
            if (command == c_AB_CommandCenterChange) {
                ord = AICreateOrder(player, command, e_AB_TransportLoadAll);
            }
            else {
                ord = AICreateOrder(player, command, e_AB_TransportLoadUnit);
                OrderSetTargetUnit(ord, unitToCheck);
            }
            break;
        }
    }
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }
    AICast(aiUnit, ord, c_noMarker, c_castHold);
    return true;
}

void AIBunkerSalvageSCBW(int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
   
    //There is no salvage ability in Legacy Mod
    //ord = AICreateOrder(player, c_BWAB_BunkerSalvage, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    if (UnitGroupCount(scanGroup, c_unitCountAlive) > 0) {
        return;
    }

    if (UnitCargoValue(aiUnit, c_unitCargoSpaceUsed) != 0) {
        return;
    }
    
    AICast(aiUnit, ord, c_noMarker, c_castHold);
}


//--------------------------------------------------------------------------------------------------
//  *** BUNKER ***
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
void AIThinkBunkerSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    BWCargoDefend(player, aiUnit, scanGroup, 8, 10, c_nullString, c_BWAB_BunkerTransport);

    //Implement Salvage?
    //if (!AIIsCampaign(player)) {
    //    if (AIPlayerDifficulty(player) >= c_skirHard_VH) {
    //        if (AIGetTime() > 900.0) {
    //            // bunkers aren't really useful after 15 minutes into a melee game
    //            // just salvage them if they aren't currently in use
    //            AIBunkerSalvageSCBW(player, aiUnit, scanGroup);
    //        }
    //    }
    //}
}

//--------------------------------------------------------------------------------------------------
//  *** MARINE ***
//--------------------------------------------------------------------------------------------------
const int c_stimpackCooldown = c_tactTimerFirst;

void AIThinkMarineSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Stimpack
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** MEDIC ***
//--------------------------------------------------------------------------------------------------
const int c_opticFlareCooldown = c_tactTimerFirst;
const int c_opticFlareMinHealth = 70;

order AIOrderOpticFlare (int player, unit aiUnit, unitgroup scanGroup, marker mark, marker gameMark ) {
    order ord;
    fixed damage;
    aifilter filterAI;
    unitfilter filterUnit;
    unitgroup targetGroup;
    //  vars related to nearby enemies.
    aifilter groundAirFilter;
    unitgroup threatGroup;
    int enemyGroundCount;
    int enemyAirCount;
    


    if (!AITactCooldownAllow(aiUnit, c_opticFlareCooldown)) {
        return null;
    }
    
    // Check UnitAbilityExists to prevent warnings in void
    if (!UnitAbilityExists(aiUnit, c_BWAB_MedicSCBWOpticFlare)) {
        return null;
    }

    ord = AICreateOrder(player, c_BWAB_MedicSCBWOpticFlare, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    } 

    //  Scan for enemy air and ground units
    //
    enemyGroundCount = 0;
    enemyAirCount = 0;

    groundAirFilter = AIFilter(player);
    AISetFilterAlliance(groundAirFilter, c_playerGroupEnemy);
    AISetFilterPlane(groundAirFilter, c_planeGround);
    enemyGroundCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    AISetFilterPlane(groundAirFilter, c_planeAir);
    enemyAirCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);


    filterAI = AIFilter(player);
    
    AISetFilterLife(filterAI, c_opticFlareMinHealth, c_noMax);
    AISetFilterMelee(filterAI, c_onlyRanged);
    AISetFilterBehaviorCount(filterAI, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_MedicSCBWOpticFlare_ABBlind);
    AISetFilterBits(filterAI, UnitFilterStr(AIAbilityStr(player, c_BWAB_MedicSCBWOpticFlare, c_fieldTargetFiltersAB)));
    AISetFilterRange(filterAI, aiUnit, AIAbilityFixed(player, c_BWAB_MedicSCBWOpticFlare, c_fieldRange0) + 1);
    AISetFilterMarker(filterAI, c_noMarkersMin, c_noMarkersMax, mark);
    //AISetFilterCanAttackEnemy(filterAI, enemyGroundCount, enemyAirCount);
    targetGroup = AIGetFilterGroup(filterAI, scanGroup);
    if (targetGroup == null) {
        return null;
    }

    //  Since it's a missile, we also have to check the game-side marker
    //
    filterAI = AIFilter(player);
    AISetFilterMarker(filterAI, c_noMarkersMin, c_noMarkersMax, gameMark);
    targetGroup = AIGetFilterGroup(filterAI, targetGroup);
    if (targetGroup == null) {
        return null;
    }

    return AIUnitGroupGetValidOrder(targetGroup, ord, aiUnit, c_forwards);
}

//if(CatalogFieldValueGet(c_gameCatalogBehavior, "", "alignment", player))
//{
//
//}

const int c_BWMedicRestorationCooldown = c_tactTimerSecond;

order AIOrderRestoration (int player, unit aiUnit, marker mark) {
    order ord;
    unitgroup group;
    aifilter filter;
    int i;
    unit tmp_unit;

    if (AIPlayerDifficulty(player) < c_campAdvanced) {
        return null;
    }
	
    if (!AITactCooldownAllow(aiUnit, c_BWMedicRestorationCooldown)) {
        return null;
    }

    ord = AICreateOrder(player, c_BWAB_MedicSCBWRestoration, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    group = AIFindUnits(player, null, UnitGetPosition(aiUnit), 
    AIAbilityFixed(player, c_BWAB_MedicSCBWRestoration, c_fieldRange0) + 1, c_noMaxCount);

    filter = AIFilter(player);
    AISetFilterAlliance(filter, c_playerGroupAlly);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    group = AIGetFilterGroup(filter, group);
    if (group == null) {
        return null;
    }

    for (i = 1; i <= UnitGroupCount(group, c_unitCountAll); i += 1) {
        tmp_unit = UnitGroupUnit(group, i);
    }

    return AIUnitGroupGetValidOrder(group, ord, aiUnit, c_forwards);
}

//--------------------------------------------------------------------------------------------------
void AIThinkMedicSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    marker mark;
    marker gameMark;
    order ord;
    int randomVal;
    fixed cooldown = 0.0;

    if (UnitGetPropertyInt(aiUnit, c_unitPropEnergy, c_unitPropCurrent) < 70) {
        return; // save at least 20 energy for healing
    }

    mark = AIMarker(aiUnit, c_BWMK_MedicSCBWOpticFlare);
    gameMark = AIMarker(aiUnit, c_BWMK_GameMedicSCBWOpticFlare);
    ord = AIOrderOpticFlare(player, aiUnit, scanGroup, mark, gameMark);

    if (ord != null) {
        if (AIIsCampaign(player)) {
            if (AIPlayerDifficulty(player) < c_campAdvanced) {
                cooldown = 7.0;
            }
            else if (AIPlayerDifficulty(player) < c_campExpert) {
                cooldown = 3.0;
            }
        }

        if (!AITactCooldownAllow(aiUnit, c_opticFlareCooldown)) {
            return;
        }

        AICastCooldown(aiUnit, ord, mark, c_castRetreat, c_opticFlareCooldown, cooldown);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** GHOST ***
//--------------------------------------------------------------------------------------------------

const fixed c_LockdownMinVitality = 70;

order Lockdown (int player, unit aiUnit, unitgroup scanGroup, marker mark, marker gameMark, bool lowVitality) {
    order ord;
    aifilter filter;
    unit target;
    unitgroup targetGroup;
    //  vars related to nearby enemies.
    aifilter groundAirFilter;
    unitgroup threatGroup;
    int enemyGroundCount;
    int enemyAirCount;
    
    //  Create order and check validity
    //
    ord = AICreateOrder(player, c_BWAB_GhostSCBWLockdown, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Scan for enemy air and ground units
    //
    enemyGroundCount = 0;
    enemyAirCount = 0;

    groundAirFilter = AIFilter(player);
    AISetFilterAlliance(groundAirFilter, c_playerGroupEnemy);
    AISetFilterPlane(groundAirFilter, c_planeGround);
    enemyGroundCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    AISetFilterPlane(groundAirFilter, c_planeAir);
    enemyAirCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    //  Apply filters to enemies
    //
    filter = AIFilter(player);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_GhostSCBWLockdown_AB);
    AISetFilterAlliance(filter, c_playerGroupEnemy);
    AISetFilterBits(filter, UnitFilterStr(AIAbilityStr(player, c_BWAB_GhostSCBWLockdown, c_fieldTargetFiltersAB)));
    AISetFilterRange(filter, aiUnit, AIAbilityFixed(player, c_BWAB_GhostSCBWLockdown, c_fieldRange0) + 1);
    AISetFilterLife(filter, c_LockdownMinVitality, c_noMax);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    AISetFilterCanAttackEnemy(filter, enemyGroundCount, enemyAirCount);
    targetGroup = AIGetFilterGroup(filter, scanGroup);
    if (targetGroup == null) {
        return null;
    }

    //  Since it's a missile, we also have to check the game-side marker
    //
    filter = AIFilter(player);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, gameMark);
    targetGroup = AIGetFilterGroup(filter, targetGroup);
    if (targetGroup == null) {
        return null;
    }

    //  Return valid target
    //
    return AIUnitGroupGetValidOrder(targetGroup, ord, aiUnit, c_forwards);
}

//--------------------------------------------------------------------------------------------------
void AIThinkGhostSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    marker mark;
    marker gameMark;
    order ord;
    bool lowVitality;

    if (AIPlayerDifficulty(player) >= c_campAdvanced) {
        // cloaking will be disabled by xml on campaign
        if (AIEvalTacticalData(aiUnit, null)) {
            return;
        }
    }

    // lockdown
    gameMark = AIMarker(aiUnit, c_BWMK_GameGhostSCBWLockdown);
    mark = AIMarker(aiUnit, c_BWMK_GhostSCBWLockdown);
    ord = Lockdown(player, aiUnit, scanGroup, mark, gameMark, lowVitality);
    if (ord != null) {
        AICast(aiUnit, ord, mark, c_castHold);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** Vulture ***
//--------------------------------------------------------------------------------------------------
const int c_secondsPerSpiderMine = 3;
const int c_vultureMineMaxRandom = c_gameLoopsPerSecond * c_secondsPerSpiderMine / c_framesPerThink;
const int c_VulturemineCooldown = c_tactTimerFirst;

order BWVultureSpiderMine (int player, unit aiUnit, unitgroup scanGroup) {
	order ord;
	fixed energy;
	point loc;
	fixed distToEnemy;
	unitgroup spiderMineGroup;
	int spiderMineCount;
    point target;
	
    if (AIPlayerDifficulty(player) < c_campAdvanced) {
        return null;
    }
	
    if (AIIsCampaign(player)) {
        if (RandomInt(0, c_vultureMineMaxRandom) != 1) {
            return null;
        }
    }

    ord = AICreateOrder(player, c_BWAB_VulturePlaceSpiderMineSCBW, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
	
	// If there are enemies nearby don't cast
	//if (UnitGroupCount(scanGroup, c_unitCountAlive) > 0) {
	//	return null;
	//}
	
	distToEnemy = AIPathDistToNearestKnownEnemyStructure(player, UnitGetPosition(aiUnit), true);//DistanceBetweenPoints(UnitGetPosition(aiUnit), PlayerStartLocation(RandomInt(1,2)));
	if (distToEnemy >= 50) {
		return null;
	}
	
	loc = UnitGetPosition(aiUnit);

	// Don't create large clusters of traps
    spiderMineGroup = UnitGroup(c_BWTU_SpiderMine_Burrowed, player, RegionCircle(loc, 10), 
                            UnitFilter(0, 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32))), 0);							
    spiderMineCount = UnitGroupCount(spiderMineGroup, c_unitCountAll);

    
    if (spiderMineCount != 0) {
        return null;
    }
    target = RegionRandomPoint(RegionCircle(loc, 7));

	OrderSetTargetPoint(ord, target);
	if (!UnitOrderIsValid(aiUnit,ord)) {
		return null;
	}
	
	return ord;
}

//--------------------------------------------------------------------------------------------------
void AIThinkVultureSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    fixed cooldown;

    if (!AITactCooldownAllow(aiUnit, c_VulturemineCooldown)) {
        return;
    }

    if (AIPlayerDifficulty(player) < c_campExpert) {
        cooldown = 8.0;
    }
    else {
        cooldown = 3.0;
    }

    ord = BWVultureSpiderMine(player, aiUnit, scanGroup);
    if (ord != null) {
        AICastCooldown(aiUnit, ord, c_noMarker, c_castHold, c_VulturemineCooldown, cooldown);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** SCIENCE VESSEL ***
//--------------------------------------------------------------------------------------------------
const int c_BWScienceVesselIrradiateCooldown = c_tactTimerFirst;
const int c_BWScienceVesselDMatrixCooldown = c_tactTimerSecond;
const int c_BWScienceVesselEMPCooldown = c_tactTimerThird;
const fixed c_EMPminShields = 50;
const fixed c_EMPminEnergy = 40;

//--------------------------------------------------------------------------------------------------

order BWScienceVesselDefensiveMatrix (int player, unit aiUnit, marker mark) {
    order ord;
    unitgroup group;
    aifilter filter;

    if (AIPlayerDifficulty(player) < c_campAdvanced) {
        return null;
    }
	
    if (!AITactCooldownAllow(aiUnit, c_BWScienceVesselDMatrixCooldown)) {
        return null;
    }

    ord = AICreateOrder(player, c_BWAB_ScienceVesselSCBWDefensiveMatrix, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    group = AIFindUnits(player, null, UnitGetPosition(aiUnit), 
    AIAbilityFixed(player, c_BWAB_ScienceVesselSCBWDefensiveMatrix, c_fieldRange0) + 1, c_noMaxCount);

    filter = AIFilter(player);
    AISetFilterAlliance(filter, c_playerGroupAlly);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    AISetFilterLifeLost(filter, AIEffectFixed(player, c_EF_Transfusion, c_fieldEffectChange0) - 20, c_noMax);
    AISetFilterInCombat(filter, c_onlyInCombat);
    group = AIGetFilterGroup(filter, group);
    if (group == null) {
        return null;
    }

    return AIUnitGroupGetValidOrder(group, ord, aiUnit, c_forwards);
}

//--------------------------------------------------------------------------------------------------
order BWScienceVesselIrradiate (int player, unit aiUnit, unitgroup scanGroup) {
    // target a clump of ranged ground units
    order ord;
    aifilter filter;
    unitgroup irradiateGroup;
	int count;
	
    if (!AITactCooldownAllow(aiUnit, c_BWScienceVesselIrradiateCooldown)) {
        return null;
    }    
	
    ord = AICreateOrder(player, c_BWAB_ScienceVesselSCBWIrradiate, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
    
    filter = AIFilter(player);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWAB_ScienceVesselSCBWIrradiate);
    AISetFilterBits(filter, UnitFilterStr("Biological;Heroic,Structure,Missile,Stasis,Item,Dead,Hidden,Invulnerable"));	
	irradiateGroup = AIGetFilterGroup(filter, scanGroup);

	count = UnitGroupCount(irradiateGroup, c_unitCountAll);
	if (count == 0) {
		return null;
	}
	
    OrderSetTargetUnit(ord, UnitGroupUnit(irradiateGroup, RandomInt(1, count)));
    if (!UnitOrderIsValid(aiUnit, ord)) {
        ord = AIUnitGroupGetValidOrder(irradiateGroup, ord, aiUnit, c_backwards);
    }
    	
    return ord;
}

//--------------------------------------------------------------------------------------------------
order BWScienceVesselShieldedEMP (int player, unit aiUnit, unitgroup scanGroup) {
    point loc;
    aifilter filter;
    unitgroup EMPGroup;

    order ord = AITacticalOrder(player, aiUnit, c_BWAB_ScienceVesselSCBWEMPShockwave);
    if (ord == null) {
        return null;
    }


    filter = AIFilter(player);
    AISetFilterShields(filter, c_EMPminShields, c_noMax);
    EMPGroup = AIGetFilterGroup(filter, scanGroup);
    

    loc = AIBestTargetPoint(
        AIEffectGroup(player, c_BWEF_ScienceVesselSCBWEMPShockwave_Search, EMPGroup),
        5, // min hits
        50, // damage base
        2.0, // score
        AIEffectFixed(player, c_BWEF_ScienceVesselSCBWEMPShockwave_Search, c_fieldAreaRadius0) + 1.0,
        UnitGetPosition(aiUnit),
        AIAbilityFixed(player, c_BWAB_ScienceVesselSCBWEMPShockwave, c_fieldRange0),
        c_unitAttributeShielded
    );

    if (loc == null) {
        return null;
    }
    
    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
    return ord;
}

//--------------------------------------------------------------------------------------------------
order BWScienceVesselEnergyEMP (int player, unit aiUnit, unitgroup scanGroup) {
    point loc;
    aifilter filter;
    unitgroup EMPGroup;

    order ord = AITacticalOrder(player, aiUnit, c_BWAB_ScienceVesselSCBWEMPShockwave);
    if (ord == null) {
        return null;
    }


    filter = AIFilter(player);
    AISetFilterEnergy(filter, c_EMPminEnergy, c_noMax);
    EMPGroup = AIGetFilterGroup(filter, scanGroup);
    

    loc = AIBestTargetPoint(
        AIEffectGroup(player, c_BWEF_ScienceVesselSCBWEMPShockwave_Search, EMPGroup),
        5, // min hits
        50, // damage base
        2.0, // score
        AIEffectFixed(player, c_BWEF_ScienceVesselSCBWEMPShockwave_Search, c_fieldAreaRadius0) + 1.0,
        UnitGetPosition(aiUnit),
        AIAbilityFixed(player, c_BWAB_ScienceVesselSCBWEMPShockwave, c_fieldRange0),
        c_unitAttributeNone
    );

    if (loc == null) {
        return null;
    }
    
    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
    return ord;
}

//--------------------------------------------------------------------------------------------------
void AIThinkScienceVesselSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unit heal;
    marker mark;
	fixed cooldown;

    if(AIPlayerDifficulty(player) < c_campAdvanced) {
		return;
	}

    ord = BWScienceVesselIrradiate(player, aiUnit, scanGroup);
    if (ord != null) {
        
		if(AIPlayerDifficulty(player) == c_campAdvanced) {
			cooldown = 22.5;
		}
		else {
			cooldown = 4.0;
		}
		AICastCooldown(aiUnit, ord, c_noMarker, c_castRetreat, c_BWScienceVesselIrradiateCooldown, cooldown);
        return;
    }

    ord = BWScienceVesselEnergyEMP(player, aiUnit, scanGroup);
    if (ord != null) {
		if(AIPlayerDifficulty(player) == c_campAdvanced) {
			cooldown = 10.0;
		}
		else {
			cooldown = 1.0;
		}		

        AICastCooldown(aiUnit, ord, c_noMarker, c_castRetreat, c_BWScienceVesselEMPCooldown, cooldown);
        return;
    }

    mark = AIMarker(aiUnit, c_BWMK_ScienceVesselSCBWDefensiveMatrix);
    ord = BWScienceVesselDefensiveMatrix(player, aiUnit, mark);
    if (ord != null) {
        
		if(AIPlayerDifficulty(player) == c_campAdvanced) {
			cooldown = 20.0;
		}
		else {
			cooldown = 10.0;
		}		
		AICastCooldown(aiUnit, ord, mark, c_castRetreat, c_BWScienceVesselDMatrixCooldown, cooldown);
        return;
    }

    ord = BWScienceVesselShieldedEMP(player, aiUnit, scanGroup);
    if (ord != null) {
		if(AIPlayerDifficulty(player) == c_campAdvanced) {
			cooldown = 15.0;
		}
		else {
			cooldown = 5.0;
		}		

        AICastCooldown(aiUnit, ord, c_noMarker, c_castRetreat, c_BWScienceVesselEMPCooldown, cooldown);
        return;
    }

    //EMP Shockwave
    //if (AIEvalTacticalData(aiUnit, null)) {
    //    return;
    //}


}

//--------------------------------------------------------------------------------------------------
//  *** WRAITH ***
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
void AIThinkWraithSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord = AICreateOrder(player, c_BWAB_WraithSCBWCloak, 0);
    bool isCloaking = true;

    if (!UnitOrderIsValid(aiUnit, ord)) {
        ord = AICreateOrder(player, c_BWAB_WraithSCBWCloak, 1);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }
        isCloaking = false;
    }

    if (isCloaking != AICloakEvaluate(aiUnit, 50, 50, 10)) {
        return;
    }
    AICast(aiUnit, ord, c_noMarker, c_castHold);
}

//--------------------------------------------------------------------------------------------------
//  *** SIEGE TANK ***
//--------------------------------------------------------------------------------------------------
void AIThinkSiegeTankSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Siege
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}
//--------------------------------------------------------------------------------------------------
//  *** SIEGE TANK SIEGED ***
//--------------------------------------------------------------------------------------------------
void AIThinkSiegeTankSCBWSieged (int player, unit aiUnit, unitgroup scanGroup) {
    //Unsiege
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** BATTLECRUISER ***
//--------------------------------------------------------------------------------------------------
const int c_BWYamatoCooldown = c_tactTimerFirst;

order BWBattlecruiserYamato (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    order ord;
    aifilter filter;
    fixed damage;
    unitgroup targetGroup;

    if (!AITactCooldownAllow(aiUnit, c_BWYamatoCooldown)) {
        return null;
    }
    //TriggerDebugOutput(1, StringToText("CD Passed"), true);

    //  If we already have a yamato order, ignore new orders so that we do not count
    //  our own markers again.
    if (UnitOrderHasAbil(aiUnit, c_BWAB_BattlecruiserSCBWYamato)) {
        return null;
    }

    if (AIPlayerDifficulty(player) < c_campAdvanced) {
        return null;
    }

    //  Only cast as part of an existing offensive.
    
    if (!AIIsAttackOrder(UnitOrder(aiUnit, 0))) {
        return null;
    }
     
    //  See if this spell can be cast at all.
    //
    ord = AICreateOrder(player, c_BWAB_BattlecruiserSCBWYamato, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    damage = AIEffectFixed(player, c_BWEF_BattlecruiserSCBWYamato_Damage, c_fieldAmount);

    //  Search enemies for those with hit points closest to the damage yamato gun inflicts.
    //
    filter = AIFilter(player);
    AISetFilterAlliance(filter, c_playerGroupEnemy);
    AISetFilterBits(filter, UnitFilterStr("-;Missile,Self,Stasis,Dead,Hidden,Invulnerable"));
    AISetFilterLifePerMarker(filter, damage, mark);
    AISetFilterLifeSortReference(filter, damage, damage*c_distanceFromDamage); 
    targetGroup = AIGetFilterGroup(filter, scanGroup);
    if (targetGroup == null) {
        return null;
    }
    
    return AIUnitGroupGetValidOrder(targetGroup, ord, aiUnit, c_backwards);
}

//--------------------------------------------------------------------------------------------------
void AIThinkBattlecruiserSCBW (int player, unit aiUnit, unitgroup scanGroup) {

    marker mark;
    order ord;
    fixed cooldown;

    mark = AIMarker(aiUnit, c_BWMK_BattlecruiserSCBWYamato);
    ord = BWBattlecruiserYamato(player, aiUnit, scanGroup, mark);

    if (!AITactCooldownAllow(aiUnit, c_BWYamatoCooldown)) {
        return;
    }

    if (ord != null) {
        if (AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campExpert) {
            cooldown = 8.0;
        }
        else {
            cooldown = 3.0;
        }
        AICastCooldown(aiUnit, ord, mark, c_castHold, c_BWYamatoCooldown, cooldown);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** FIREBAT ***
//--------------------------------------------------------------------------------------------------
void AIThinkFirebatSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Stimpack
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** NUCLEAR SILO ***
//--------------------------------------------------------------------------------------------------
const int c_BWMinGhostCount = 1;

//--------------------------------------------------------------------------------------------------
void AIThinkNuclearSiloSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    int ghostCount;
    order ord;

    ord = AICreateOrder(player, c_BWAB_NukeSCBWArm, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    ghostCount = TechTreeUnitCount(player, c_BWTU_Ghost, c_techCountQueuedOrBetter);
    if (ghostCount >= c_BWMinGhostCount) {
        if (ord != null) {
            AICast(aiUnit, ord, c_noMarker, c_castHold);
            return;
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  *** COMMAND CENTER ***
//--------------------------------------------------------------------------------------------------

const int c_BWCommandCenterEarlyCount = 1;
const int c_BWComsatMaxCount = 2;
const int c_BWGhostMinCount = 1;

//--------------------------------------------------------------------------------------------------
void AIThinkCommandCenterSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    int commandCenterCount;
    int comsatStationCount;
    int nuclearSiloCount;
    int ghostCount;
    order ord;

    //Count Units
    commandCenterCount = TechTreeUnitCount(player, c_BWTB_CommandCenter, c_techCountQueuedOrBetter);
    comsatStationCount = TechTreeUnitCount(player, c_BWTB_ComsatStation, c_techCountQueuedOrBetter);
    nuclearSiloCount = TechTreeUnitCount(player, c_BWTB_NuclearSilo, c_techCountQueuedOrBetter);
    ghostCount = TechTreeUnitCount(player, c_BWTU_Ghost, c_techCountQueuedOrBetter);

    ////rally
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }

    ord = AICreateOrder(player, c_BWAB_CommandCenterSCBW_AddOns, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    //Only build one if there is Detection Danger
    if (AISuspectDetectionDanger(player, 60 * 3)){
        if (commandCenterCount < c_BWComsatMaxCount) {
            if (comsatStationCount < c_BWComsatMaxCount) {
                if (ord != null) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                    return;
                }
            }
        }
    }

    // Build Additional Comsats if there is detection danger late in the game
    if (AISuspectDetectionDanger(player, c_lateDetectionDangerTime)){
        if (commandCenterCount <= c_BWComsatMaxCount) {
            if (comsatStationCount < c_BWComsatMaxCount) {
                if (ord != null) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                    return;
                }
            }
        }
    }

    ord = AICreateOrder(player, c_BWAB_CommandCenterSCBW_AddOns, 1);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    if (commandCenterCount > c_BWComsatMaxCount && comsatStationCount >= c_BWComsatMaxCount) {
        if (ghostCount >= c_BWGhostMinCount) {
            if (ord != null) {
                AICast(aiUnit, ord, c_noMarker, c_castHold);
                return;
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//  *** COMSAT STATION ***
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  Scanner Sweep
//--------------------------------------------------------------------------------------------------
bool ComsatScannerSweep (int player, unit aiUnit) {
    order ord;
    point loc;
    bool needsNearbyAttackers;

    ord = AICreateOrder(player, c_BWAB_ComsatStationSCBWScannerSweep, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    //  If something is attacking while cloaked and we can defend if we reveal it, cast sweep.
    //
    loc = AIGetCloakedAttacker(player);  // includes unscanned detect beacon
    if (loc == null) {
        return false;
    }
    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }
    
    needsNearbyAttackers = true;
    if (PlayerBeaconIsSet(player, c_beaconDetect)) {
        if (loc == PlayerBeaconGetTargetPoint(player, c_beaconDetect)) {
            needsNearbyAttackers = false;
        }
    }

    if (needsNearbyAttackers && !AIHasNearbyAlliedAttackers(player, loc, 10.0)) {
        return false;
    }

    AICast(aiUnit, ord, c_noMarker, c_castHold);
    AIClearCloakedAttacker(player, loc);
    return true;
}

//--------------------------------------------------------------------------------------------------
void AIThinkComsatStationSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    if (ComsatScannerSweep(player, aiUnit)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** BARRACKS ***
//--------------------------------------------------------------------------------------------------
void AIThinkBarracksSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //rally
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** FACTORY ***
//--------------------------------------------------------------------------------------------------
void AIThinkFactorySCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //rally
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** STARPORT ***
//--------------------------------------------------------------------------------------------------
void AIThinkStarportSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //rally
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  BW Terran Upgrade Buildings (Melee)
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  *** ENGINEERING BAY ***
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
void AIThinkEngineeringBaySCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    int infantryUnitCount;
    
    if(AIIsCampaign(player)) {
        return;
    }

    // Only counts Combat Infantry Units
    infantryUnitCount = 
    TechTreeUnitCount(player, c_BWTU_Marine, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWTU_Firebat, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWTU_Ghost, c_techCountQueuedOrBetter);


    //Tier 1
    if(TechTreeUpgradeCount(player, c_BWTR_TerranInfantryWeaponsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranInfantryWeapons, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (infantryUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranInfantryArmorsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranInfantryArmorsSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (infantryUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2
    if(TechTreeUpgradeCount(player, c_BWTR_TerranInfantryWeaponsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranInfantryWeapons, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (infantryUnitCount >= 8) {
                if   (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranInfantryArmorsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranInfantryArmorsSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (infantryUnitCount >= 8) {
                if   (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3
    if(TechTreeUpgradeCount(player, c_BWTR_TerranInfantryWeaponsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranInfantryWeapons, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (infantryUnitCount >= 10) {
                if   (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranInfantryArmorsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranInfantryArmorsSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (infantryUnitCount >= 10) {
                if   (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  *** ARMORY ***
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
void AIThinkArmorySCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    int mechUnitCount;
    int airUnitCount;

    if(AIIsCampaign(player)) {
        return;
    }

    // Only counts Combat Mech Units
    mechUnitCount = 
    TechTreeUnitCount(player, c_BWTU_Vulture, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWTU_Goliath, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWTU_SiegeTank, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWTU_SiegeTankSieged, c_techCountQueuedOrBetter);

    // Only counts Combat Air Units
    airUnitCount = 
    TechTreeUnitCount(player, c_BWTU_Wraith, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWTU_Valkyrie, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWTU_Battlecruiser, c_techCountQueuedOrBetter);

    //Tier 1 Mech
    if(TechTreeUpgradeCount(player, c_BWTR_TerranVehicleWeaponsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranVehicleWeaponsSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (mechUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranVehiclePlatingSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranVehiclePlatingSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (mechUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 1 Ship
    if(TechTreeUpgradeCount(player, c_BWTR_TerranShipWeaponsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranShipWeaponsSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranShipPlatingSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranShipPlatingSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Mech
    if(TechTreeUpgradeCount(player, c_BWTR_TerranVehicleWeaponsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranVehicleWeaponsSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (mechUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranVehiclePlatingSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranVehiclePlatingSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (mechUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Ship
    if(TechTreeUpgradeCount(player, c_BWTR_TerranShipWeaponsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranShipWeaponsSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranShipPlatingSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranShipPlatingSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Mech
    if(TechTreeUpgradeCount(player, c_BWTR_TerranVehicleWeaponsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranVehicleWeaponsSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (mechUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranVehiclePlatingSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranVehiclePlatingSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (mechUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Ship
    if(TechTreeUpgradeCount(player, c_BWTR_TerranShipWeaponsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranShipWeaponsSCBW, 20);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWTR_TerranShipPlatingSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWTR_TerranShipPlatingSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  BW Protoss
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  *** ARBITER ***
//--------------------------------------------------------------------------------------------------

const int c_BWStasisCooldown = c_tactTimerFirst;

//Stasis
order BWStasis (int player, unit aiUnit, marker mark, marker gameMark, unitgroup scanGroup) {
    order ord;
    fixed energy;
    aifilter filter;
    bool groundAllies;
    unitgroup enemyGroup;
    point loc;
    
    if (!AITactCooldownAllow(aiUnit, c_BWStasisCooldown)) {
        return null;
    }

    ord = AICreateOrder(player, c_BWAB_ArbiterSCBWStasisField, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Cast on strongest enemy that can attack our allies
    filter = AIFilter(player);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_ArbiterSCBWStasisField_AB);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, gameMark);
    enemyGroup = AIGetFilterGroup(filter, scanGroup);

    loc = AIBestTargetPoint(
        AIEffectGroup(player, c_BWEF_ArbiterSCBWStasisField_Search, enemyGroup),
        5, // min hits
        30, // damage base
        3.5, // min score
        AIEffectFixed(player, c_BWEF_ArbiterSCBWStasisField_Search, c_fieldAreaRadius0),
        UnitGetPosition(aiUnit),
        AIUnitFixed(player, c_BWPU_Arbiter, c_fieldSightRange), 
        c_unitAttributeNone
    );
    if (loc == null) {
        return null;
    }
    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
    return ord;
}

//--------------------------------------------------------------------------------------------------
void AIThinkArbiterSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    marker mark;
    marker gameMark;
    order ord;
    fixed cooldown;

    // Stasis Field
    gameMark = AIMarker(aiUnit, c_BWMK_ArbiterSCBWGameStasisField);
    mark = AIMarker(aiUnit, c_BWMK_ArbiterSCBWStasisField);
    ord = BWStasis(player, aiUnit, mark, gameMark, scanGroup);
    if (ord != null) {
        if (AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campAdvanced) {
            cooldown = 20.0;
        }
        else {
            cooldown = 1.0;
        }
        AICastCooldown(aiUnit, ord, mark, c_castHold, c_BWStasisCooldown, cooldown);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** HIGH TEMPLAR ***
//--------------------------------------------------------------------------------------------------

const int c_BWPsiStormCooldown = c_tactTimerFirst;

//---------------------------------------------------------------------------------------------
bool BWMergeToSurvive (int player, unit aiUnit, unitgroup scanGroup) {
    // only called at low heatlh, try to find a nearby templar to merge with in order to survive
    order ord;
    unitgroup targetGroup;
    unit targetUnit;
    
    if (AIIsCampaign(player)) {
        return false;
    }
    
    // if we're not under attack, don't try to merge
    if (AILastAttack(aiUnit) < (AIGetTime() - 4.0)) {
        return false;
    }
    
    ord = AICreateOrder(player, c_BWAB_ArchonSCBWMerge, 1);
    targetGroup = UnitGroupSearch(c_BWPU_HighTemplar, player, UnitGetPosition(aiUnit), 5.0, UnitFilter((1 << c_targetFilterSelf), 0, 0, 0), c_noMaxCount);
    targetUnit =  OrderGetTargetUnit( AIUnitGroupGetValidOrder(targetGroup, ord, aiUnit, c_forwards) );
    if (targetUnit == null) {
        return false;
    }
    
    // can't use the normal AICast because both units need the order at the same time
    UnitIssueOrder(aiUnit, OrderTargetingUnit(AbilityCommand(c_BWAB_ArchonSCBWMerge, 1), targetUnit), c_orderQueueAddToEnd);
    UnitIssueOrder(targetUnit, OrderTargetingUnit(AbilityCommand(c_BWAB_ArchonSCBWMerge, 1), aiUnit), c_orderQueueAddToEnd);
    AISetUnitScriptControlled(aiUnit, false);
    AISetUnitScriptControlled(targetUnit, false);
    return true;
}

//--------------------------------------------------------------------------------------------------
void AIThinkHighTemplarSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    marker mark;
    order ord;
    fixed cooldown;
    bool lowVitality;

    //Psionic Storm
    //AI can now use the Psi Storm in Campaign but requires additional changes
    if (AIPlayerDifficulty(player) >= c_campAdvanced) {
        if (AITactCooldownAllow(aiUnit, c_BWPsiStormCooldown)) {
            
            if (AIEvalTacticalData(aiUnit, null)) {        
                if (AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campExpert) {
                    AISetCooldown(aiUnit, c_BWPsiStormCooldown, 5.0);
                }
                return;
            }
        }
    }

    if (AIIsCampaign(player)) {
        // not using hallucination or merge to survive in campaign
        return;
    }

    //  If we already have a psi storm order, ignore any new orders since psi storm is more important.
    if (UnitOrderHasAbil(aiUnit, c_BWAB_HighTemplarSCBWPsiStorm)) {
        return;
    }
    
    lowVitality = (UnitGetPropertyInt(aiUnit, c_unitPropVitalityPercent, c_unitPropCurrent) < c_HighTemplarLowVitPerc);

    if (lowVitality) {
        if (BWMergeToSurvive(player, aiUnit, scanGroup)) {
            return;
        }
    }
    
    //We're not using hallucination as it doesn't feel right while playing
    //Hallucination might be implemented at a later date
}

//--------------------------------------------------------------------------------------------------
//  *** CORSAIR ***
//--------------------------------------------------------------------------------------------------

const int c_BWDisruptionWebCooldown = c_tactTimerFirst;

//Disruption Web
order BWDisruptionWeb (int player, unit aiUnit, unitgroup scanGroup) {
    // target a clump of ranged ground units
    order ord;
    aifilter filter;
    unitgroup rangedGroup;
    point loc;

    ord = AICreateOrder(player, c_BWAB_CorsairSCBWDisruptionWeb, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
    
    filter = AIFilter(player);
    AISetFilterMelee(filter, c_onlyRanged);
    AISetFilterPlane(filter, c_planeGround);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_CorsairSCBWDisruptionWeb_AB);
    rangedGroup = AIGetFilterGroup(filter, scanGroup);

    loc = AIBestTargetPoint(
        AIEffectGroup(player, c_BWEF_CorsairSCBWDisruptionWeb_Search, rangedGroup),
        5, // min hits
        10, // damage base
        4.5, // min score 
        AIEffectFixed(player, c_BWEF_CorsairSCBWDisruptionWeb_Search, c_fieldAreaRadius0),
        UnitGetPosition(aiUnit),
        AIAbilityFixed(player, c_BWAB_CorsairSCBWDisruptionWeb, c_fieldRange0)+3,
        c_unitAttributeNone
    );
    if (loc == null) {
        return null;
    }

    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}

//--------------------------------------------------------------------------------------------------
void AIThinkCorsairSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    fixed cooldown;

    //Cast Disruption Web
    ord = BWDisruptionWeb(player, aiUnit, scanGroup);
    if (ord != null) {
        if (AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campExpert) {
            cooldown = 4.0;
        }
        else {
            cooldown = 1.0;
        }
        AICastCooldown(aiUnit, ord, c_noMarker, c_castHold, c_BWDisruptionWebCooldown, cooldown);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** DARK ARCHON ***
//--------------------------------------------------------------------------------------------------

//Feedback
const int c_maelstromCooldown = c_tactTimerSecond;
const int c_BWFeedbackMinDamageNormal = 100;
const int c_BWFeedbackMinDamageLowVitality = 50;
const fixed c_BWMindControlMinVitality = 125;

//---------------------------------------------------------------------------------------------
order BWFeedback (int player, unit aiUnit, unitgroup scanGroup, marker mark, bool lowVitality) {
    order ord;
    fixed damage;
    aifilter filter;
    int minEnergy;
    unitgroup targetGroup;

    ord = AICreateOrder(player, c_BWAB_DarkArchonSCBWFeedback, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    } 

    if (lowVitality) {
        minEnergy = c_BWFeedbackMinDamageLowVitality;
    }
    else {
        minEnergy = c_BWFeedbackMinDamageNormal;
    }

    filter = AIFilter(player);
    AISetFilterAlliance(filter, c_playerGroupEnemy);
    AISetFilterBits(filter, UnitFilterStr(AIAbilityStr(player, c_BWAB_DarkArchonSCBWFeedback, c_fieldTargetFiltersAB)));
    AISetFilterRange(filter, aiUnit, AIAbilityFixed(player, c_BWAB_DarkArchonSCBWFeedback, c_fieldRange0) + 1);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    AISetFilterEnergy(filter, minEnergy, c_noMax);

    //  Pick a valid target
    targetGroup = AIGetFilterGroup(filter, scanGroup);
    if (targetGroup == null) {
        return null;
    }

    return AIUnitGroupGetValidOrder(targetGroup, ord, aiUnit, c_forwards);
}

//---------------------------------------------------------------------------------------------
order BWMindControl (int player, unit aiUnit, unitgroup scanGroup, marker mark, bool lowVitality) {
    order ord;
    aifilter filter;
    unit target;
    unitgroup targetGroup;
    //  vars related to nearby enemies.
    aifilter groundAirFilter;
    unitgroup threatGroup;
    int enemyGroundCount;
    int enemyAirCount;
    
    //  Create order and check validity
    //
    ord = AICreateOrder(player, c_BWAB_DarkArchonSCBWMindControl, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Scan for enemy air and ground units
    //
    enemyGroundCount = 0;
    enemyAirCount = 0;

    groundAirFilter = AIFilter(player);
    AISetFilterAlliance(groundAirFilter, c_playerGroupEnemy);
    AISetFilterPlane(groundAirFilter, c_planeGround);
    enemyGroundCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    AISetFilterPlane(groundAirFilter, c_planeAir);
    enemyAirCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    //  Apply filters to enemies
    //
    filter = AIFilter(player);
    AISetFilterAlliance(filter, c_playerGroupEnemy);
    AISetFilterBits(filter, UnitFilterStr(AIAbilityStr(player, c_BWAB_DarkArchonSCBWMindControl, c_fieldTargetFiltersAB)));
    AISetFilterRange(filter, aiUnit, AIAbilityFixed(player, c_BWAB_DarkArchonSCBWMindControl, c_fieldRange0) + 1);
    AISetFilterLife(filter, c_BWMindControlMinVitality, c_noMax);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    //AISetFilterCanAttackEnemy(filter, enemyGroundCount, enemyAirCount);
    targetGroup = AIGetFilterGroup(filter, scanGroup);
    if (targetGroup == null) {
        return null;
    }

    //  Return valid target
    //
    return AIUnitGroupGetValidOrder(targetGroup, ord, aiUnit, c_forwards);
}

//---------------------------------------------------------------------------------------------
order BWMaelstrom (int player, unit aiUnit, marker mark, unitgroup scanGroup) {
    order ord;
    fixed energy;
    aifilter filter;
    bool groundAllies;
    unitgroup enemyGroup;
    point loc;
    
    if (!AITactCooldownAllow(aiUnit, c_maelstromCooldown)) {
        return null;
    }

    ord = AICreateOrder(player, c_BWAB_DarkArchonSCBWMaelstrom, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Cast on strongest enemy that can attack our allies
    filter = AIFilter(player);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_DarkArchonSCBWMaelstrom_AB);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    enemyGroup = AIGetFilterGroup(filter, scanGroup);

    loc = AIBestTargetPoint(
        AIEffectGroup(player, c_BWEF_DarkArchonSCBWMaelstrom_Search, enemyGroup),
        5, // min hits
        30, // damage base
        3.5, // min score
        AIEffectFixed(player, c_BWEF_DarkArchonSCBWMaelstrom_Search, c_fieldAreaRadius0),
        UnitGetPosition(aiUnit),
        AIUnitFixed(player, c_BWPU_DarkArchon, c_fieldSightRange), 
        c_unitAttributeBiological
    );
    if (loc == null) {
        return null;
    }
    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
    return ord;
}

void AIThinkDarkArchonSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    marker mark;
    order ord;
    bool lowVitality;
    unitfilter f;
    region r;
    unitgroup enemyGroup;
    fixed cooldown;

    lowVitality = (UnitGetPropertyInt(aiUnit, c_unitPropVitalityPercent, c_unitPropCurrent) < c_HighTemplarLowVitPerc);

    // feedback
    mark = AIMarker(aiUnit, c_BWMK_DarkArchonSCBWFeedback);
    ord = BWFeedback(player, aiUnit, scanGroup, mark, lowVitality);
    if (ord != null) {
        AICast(aiUnit, ord, mark, c_castRetreat);
        return;
    }
    
    //Maelstrom
    mark = AIMarker(aiUnit, c_BWMK_DarkArchonSCBWMaelstrom);
    ord = BWMaelstrom(player, aiUnit, mark, scanGroup);
    if (ord != null) {
        if (AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campAdvanced) {
            cooldown = 15.0;
        }
        else {
            cooldown = 2.0;
        }
        AICastCooldown(aiUnit, ord, mark, c_castHold, c_maelstromCooldown, cooldown);
        return;
    }


    // mind control
    mark = AIMarker(aiUnit, c_BWMK_DarkArchonSCBWMindControl);
    ord = BWMindControl(player, aiUnit, scanGroup, mark, lowVitality);
    if (ord != null) {
        AICast(aiUnit, ord, mark, c_castRetreat);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** CARRIER ***
//--------------------------------------------------------------------------------------------------
void AIThinkCarrierSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Hangar
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** REAVER ***
//--------------------------------------------------------------------------------------------------
void AIThinkReaverSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Hangar
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** NEXUS ***
//--------------------------------------------------------------------------------------------------

void AIThinkNexusSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Rally
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** GATEWAY ***
//--------------------------------------------------------------------------------------------------
void AIThinkGatewaySCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Rally
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** ROBOTICS FACILITY ***
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
void AIThinkRoboticsFacilitySCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Rally
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** STARGATE ***
//--------------------------------------------------------------------------------------------------
void AIThinkStargateSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Rally
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  BW Protoss Upgrade Buildings (Melee)
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  *** FORGE ***
//--------------------------------------------------------------------------------------------------
void AIThinkForgeSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    int groundUnitCount;
    int totalUnitCount;

    if(AIIsCampaign(player)) {
        return;
    }

    // Counts all Combatant Ground Units
    groundUnitCount = 
    TechTreeUnitCount(player, c_BWPU_Zealot, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Dragoon, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_DarkTemplar, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Archon, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Reaver, c_techCountQueuedOrBetter);

    // Counts all Protoss Units Air or Ground
    totalUnitCount = 
    groundUnitCount +
    TechTreeUnitCount(player, c_BWPU_Arbiter, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Scout, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Corsair, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Carrier, c_techCountQueuedOrBetter);


    //Tier 1 Ground Weapons
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossGroundWeaponsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossGroundWeaponsSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 1 Ground Armors
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossGroundArmorsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossGroundArmorsSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 1 Shields
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossShieldsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossShieldsSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (totalUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Ground Weapons
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossGroundWeaponsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossGroundWeaponsSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Ground Armors
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossGroundArmorsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossGroundArmorsSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Shields
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossShieldsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossShieldsSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (totalUnitCount >= 7) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Ground Weapons
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossGroundWeaponsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossGroundWeaponsSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 8) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Ground Armors
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossGroundArmorsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossGroundArmorsSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 8) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Shields
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossShieldsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossShieldsSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (totalUnitCount >= 8) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  *** CYBERNETICS CORE ***
//--------------------------------------------------------------------------------------------------
void AIThinkCyberneticsCoreSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    int airUnitCount;
    int totalUnitCount;

    if(AIIsCampaign(player)) {
        return;
    }

    // Counts all Combatant Air Units
    airUnitCount = 
    TechTreeUnitCount(player, c_BWPU_Scout, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Corsair, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Arbiter, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWPU_Carrier, c_techCountQueuedOrBetter);

    //Tier 1 Air Weapons
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossAirWeaponsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossAirWeaponsSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 1 Air Armors
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossAirArmorsSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossAirArmorsSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Air Weapons
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossAirWeaponsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossAirWeaponsSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Air Armors
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossAirArmorsSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossAirArmorsSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 5) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Air Weapons
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossAirWeaponsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossAirWeaponsSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Air Armors
    if(TechTreeUpgradeCount(player, c_BWPR_ProtossAirArmorsSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWPR_ProtossAirArmorsSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  BW Zerg
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  *** QUEEN ***
//--------------------------------------------------------------------------------------------------
const int c_BWSpawnBroodlingsCooldown = c_tactTimerFirst;
const int c_BWEnsnareCooldown = c_tactTimerSecond;
const int c_BWParasiteCooldown = c_tactTimerThird;

//--------------------------------------------------------------------------------------------------
order BWQueenParasite (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    // Targetted shot that grants vision on target
    // Cast Parasite on massive units and siege targets
    order ord;
    unitgroup filterGroup;
    unit unitToCheck;
    int scanCount;

    ord = AICreateOrder(player, c_BWAB_QueenSCBWParasite, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    filterGroup = UnitGroupEmpty();

    scanCount = UnitGroupCount(scanGroup, c_unitCountAll);
    if(scanCount == 0) {
        return null;
    }

    while (scanCount > 0) {
        unitToCheck = UnitGroupUnit(scanGroup, scanCount);
        scanCount = scanCount - 1;

        if (UnitHasBehavior(unitToCheck, c_BWAB_QueenSCBWParasite)) {
            return null; // Unit with parasite exists in the group
        }

        if (UnitMarkerCount(unitToCheck, mark) > 0) {
            return null; // Already marked unit exists in group
        }

        if (UnitTypeTestAttribute(UnitGetType(unitToCheck), c_unitAttributeHeroic) == true) {
            UnitGroupAdd(filterGroup, unitToCheck);
        }
        else if (UnitTypeTestAttribute(UnitGetType(unitToCheck), c_unitAttributeArmored) == true) {
            UnitGroupAdd(filterGroup, unitToCheck);
        }
        else if (UnitGetType(unitToCheck) == c_TU_SiegeTank || UnitGetType(unitToCheck) == c_TU_SiegeTankSieged) {
            UnitGroupAdd(filterGroup, unitToCheck);
        }
    }

    return AIUnitGroupGetValidOrder(filterGroup, ord, aiUnit, c_forwards);
}

//--------------------------------------------------------------------------------------------------
order BWQueenEnsnare (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    // AOE that slows units in an area for a duration
    order ord;
    point loc;
    aifilter filter;
    unitgroup enemyGroup;
    //  vars related to nearby enemies.
    aifilter groundAirFilter;
    unitgroup threatGroup;
    int enemyGroundCount;
    int enemyAirCount;

    if (!AITactCooldownAllow(aiUnit, c_BWEnsnareCooldown)) {
        return null;
    }

    ord = AICreateOrder(player, c_BWAB_QueenSCBWEnsnare, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Scan for enemy air and ground units
    //
    enemyGroundCount = 0;
    enemyAirCount = 0;

    groundAirFilter = AIFilter(player);
    AISetFilterAlliance(groundAirFilter, c_playerGroupEnemy);
    AISetFilterPlane(groundAirFilter, c_planeGround);
    enemyGroundCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    AISetFilterPlane(groundAirFilter, c_planeAir);
    enemyAirCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    // Ensnare units that have not been already marked or has existing behavior
    filter = AIFilter(player);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_QueenSCBWEnsnare_AB);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_QueenSCBWEnsnareMovement_AB);
    //AISetFilterLifePerMarker(filter, damage, mark);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    AISetFilterCanAttackEnemy(filter, enemyGroundCount, enemyAirCount);
    AISetFilterAlliance(filter, c_playerGroupEnemy);

    enemyGroup = AIGetFilterGroup(filter, scanGroup);
    if (enemyGroup == null) {
        return null;
    }

    loc = AIBestTargetPoint(
        enemyGroup,
        2, // min hits
        20, // damage base
        1.5, // min score 
        AIEffectFixed(player, c_BWEF_QueenSCBWEnsnare_Search, c_fieldAreaRadius0),
        UnitGetPosition(aiUnit),
        AIAbilityFixed(player, c_BWAB_QueenSCBWEnsnare, c_fieldRange0)+3,
        c_unitAttributeNone
    );
    if (loc == null) {
        return null;
    }

    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}

//--------------------------------------------------------------------------------------------------
order BWQueenSpawnBroodlings (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    // Targetted shot that kills the target and spawns to Broodlings at that location
    // Spawn Broodlings on massive units and siege targets
    order ord;
    unitgroup filterGroup;
    unit unitToCheck;
    int scanCount;


    if (!AITactCooldownAllow(aiUnit, c_BWSpawnBroodlingsCooldown)) {
        return null;
    }
    
    ord = AICreateOrder(player, c_BWAB_QueenSCBWSpawnBroodlings, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    filterGroup = UnitGroupEmpty();

    scanCount = UnitGroupCount(scanGroup, c_unitCountAll);
    if(scanCount == 0) {
        return null;
    }

    while (scanCount > 0) {
        unitToCheck = UnitGroupUnit(scanGroup, scanCount);
        scanCount = scanCount - 1;

        if (UnitHasBehavior(unitToCheck, c_BWAB_QueenSCBWParasite)) {
            continue; // Ignore unit with parasite
        }

        if (UnitMarkerCount(unitToCheck, mark) > 0) {
            continue; // Ignore unit marked for SpawnBroodling
        }

        if (UnitTypeTestAttribute(UnitGetType(unitToCheck), c_unitAttributeHeroic) == true) {
            UnitGroupAdd(filterGroup, unitToCheck);
        }
        else if (UnitTypeTestAttribute(UnitGetType(unitToCheck), c_unitAttributeMassive) == true) {
            UnitGroupAdd(filterGroup, unitToCheck);
        }
        else if (UnitTypeTestAttribute(UnitGetType(unitToCheck), c_unitAttributeBiological) == true) {
            UnitGroupAdd(filterGroup, unitToCheck);
        }
        //else if (UnitGetType(unitToCheck) == c_BWPU_DarkArchon || UnitGetType(unitToCheck) == c_BWPU_DarkArchon) {
        //    UnitGroupRemove(filterGroup, unitToCheck);
        //}
        //else if (UnitGetType(unitToCheck) == c_BWPU_Archon || UnitGetType(unitToCheck) == c_BWPU_Archon) {
        //    UnitGroupRemove(filterGroup, unitToCheck);
        //}
    }

    return AIUnitGroupGetValidOrder(filterGroup, ord, aiUnit, c_forwards);
}

//--------------------------------------------------------------------------------------------------
void AIThinkQueenSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    marker mark;
    fixed cooldown;

    mark = AIMarker(aiUnit, c_BWMK_QueenSCBWSpawnBroodlings);
    ord = BWQueenSpawnBroodlings(player, aiUnit, scanGroup, mark);
    if (ord != null) {
        if (AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campAdvanced) {
            cooldown = 15.0;
        }
        else {
            cooldown = 1.0;
        }
        AICastCooldown(aiUnit, ord, mark, c_castRetreat, c_BWSpawnBroodlingsCooldown, cooldown);
        return;
    }

    mark = AIMarker(aiUnit, c_BWMK_QueenSCBWEnsnare);
    ord = BWQueenEnsnare(player, aiUnit, scanGroup, mark);
    if (ord != null) {
        if (AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campAdvanced) {
            cooldown = 15.0;
        }
        else {
            cooldown = 5.0;
        }
        AICastCooldown(aiUnit, ord, mark, c_castRetreat, c_BWEnsnareCooldown, cooldown);
        return;
    }

    mark = AIMarker(aiUnit, c_BWMK_QueenSCBWParasite);
    ord = BWQueenParasite(player, aiUnit, scanGroup, mark);
    if (ord != null) {
        if (AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campAdvanced) {
            cooldown = 20.0;
        }
        else {
            cooldown = 10.0;
        }
        AICastCooldown(aiUnit, ord, mark, c_castRetreat, c_BWParasiteCooldown, cooldown);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** Defiler ***
//--------------------------------------------------------------------------------------------------

const int c_BWDarkSwarmCooldown = c_tactTimerFirst;
const int c_BWConsumeCooldown = c_tactTimerSecond;
const int c_BWPlagueCooldown = c_tactTimerThird;

order BWDarkSwarm (int player, unit aiUnit, unitgroup scanGroup) {
    // target a clump of ranged ground units
    order ord;
    aifilter filter;
    unitgroup nearbyAlliedUnits;
    unitgroup rangedGroup;
    point loc;

    ord = AICreateOrder(player, c_BWAB_DefilerSCBWDarkSwarm, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
    
    filter = AIFilter(player);
    //AISetFilterMelee(filter, c_onlyRanged);
    AISetFilterPlane(filter, c_planeGround);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_DefilerSCBWDarkSwarm_AB);
    AISetFilterAlliance(filter, c_playerGroupAlly);
    //AISetFilterCanAttackAlly(filter, c_groundAlliesNearby, false);
    rangedGroup = AIGetFilterGroup(filter, scanGroup);

    loc = AIBestTargetPoint(
        AIEffectGroup(player, c_BWEF_DefilerSCBWDarkSwarm_Search, rangedGroup),
        5, // min hits
        10, // damage base
        4.5, // min score 
        AIEffectFixed(player, c_BWEF_DefilerSCBWDarkSwarm_Search, c_fieldAreaRadius0),
        UnitGetPosition(aiUnit),
        AIAbilityFixed(player, c_BWAB_DefilerSCBWDarkSwarm, c_fieldRange0)+3,
        c_unitAttributeNone
    );
    if (loc == null) {
        return null;
    }

    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}

order BWDefilerConsume (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
	unit target;
    unitgroup nearbyAlliedUnits;
    aifilter filter;
    order ord;
    fixed energy;
    
    if (!AITactCooldownAllow(aiUnit, c_BWConsumeCooldown)) {
        return null;
    }

    // Only get enough energy for one or two spells Max
    energy = UnitGetPropertyInt(aiUnit, c_unitPropEnergy, c_unitPropCurrent);
    if (energy >= 175) {
        return null;
    }

    ord = AICreateOrder(player, c_BWAB_DefilerSCBWConsume, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }
    
    // Only try to eat Zerglings as they're the weakest unit
    nearbyAlliedUnits = AIFindUnits(player, c_BWZU_Zergling, UnitGetPosition(aiUnit), 5, 10);
    
    if(UnitGroupCount(nearbyAlliedUnits, c_unitCountAlive) < 4){
        return null;
    }

    filter = AIFilter(player);
    AISetFilterPlane(filter, c_planeGround);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
	nearbyAlliedUnits = AIGetFilterGroup(filter, nearbyAlliedUnits);
    target = AIGetClosestUnit(aiUnit, nearbyAlliedUnits, true);

	if (target == null) {
		return null;
	}
	
	OrderSetTargetUnit(ord, target);
	if (!UnitOrderIsValid(aiUnit,ord)) {
		return null;
	}
	
	return ord;
}

order BWDefilerPlague (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    // target a clump of air units
    order ord;
    aifilter filter;
    unitgroup enemyGroup;
    point loc;
    unit target;
    //  vars related to nearby enemies.
    aifilter groundAirFilter;
    unitgroup threatGroup;
    int enemyGroundCount;
    int enemyAirCount;
    
    // Check UnitAbilityExists to prevent warnings in liberty/swarm
    if (!UnitAbilityExists(aiUnit, c_BWAB_DefilerSCBWPlague)) {
        return null;
    }

    ord = AICreateOrder(player, c_BWAB_DefilerSCBWPlague, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Scan for enemy air and ground units
    //
    enemyGroundCount = 0;
    enemyAirCount = 0;

    groundAirFilter = AIFilter(player);
    AISetFilterAlliance(groundAirFilter, c_playerGroupEnemy);
    AISetFilterPlane(groundAirFilter, c_planeGround);
    enemyGroundCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    AISetFilterPlane(groundAirFilter, c_planeAir);
    enemyAirCount = UnitGroupCount(AIGetFilterGroup(groundAirFilter, scanGroup), c_unitCountAlive);

    filter = AIFilter(player);
    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_DefilerSCBWPlague_AB);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    AISetFilterAlliance(filter, c_playerGroupEnemy);
    AISetFilterCanAttackEnemy(filter, enemyGroundCount, enemyAirCount);
    enemyGroup = AIGetFilterGroup(filter, scanGroup);
    
    loc = AIBestTargetPoint(
        enemyGroup,
        1, // min hits
        50, // damage base
        0.5, // min score 
        AIEffectFixed(player, c_BWEF_DefilerSCBWPlague_Search, c_fieldAreaRadius0),
        UnitGetPosition(aiUnit),
        AIAbilityFixed(player, c_BWAB_DefilerSCBWPlague, c_fieldRange0)+0,
        c_unitAttributeNone
    );
    if (loc == null) {
        return null;
    }

    target = UnitGroupClosestToPoint(enemyGroup, loc);
    OrderSetTargetUnit(ord, target);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}


//
//region[c_maxPlayers] g_BWDefilerDarkSwarmNoCast;
//region[c_maxPlayers][11] g_BWDefilerDarkSwarmNoCastTemp;
//int[c_maxPlayers] g_BWDefilerDarkSwarmNoCastCount;
//
//
////--------------------------------------------------------------------------------------------------
//// Trigger: DarkSwarmNoCastRegion
////--------------------------------------------------------------------------------------------------
//void gf_DeclareDarkSwarmNoCastRegion() {
//    point pos;
//    fixed radius;
//    int player = EventPlayer();
//    int index = -1;
//    int i;
//
//    if(g_BWDefilerDarkSwarmNoCastCount[player] >= 11){ return;}
//    if(g_BWDefilerDarkSwarmNoCast[player] == null){
//        g_BWDefilerDarkSwarmNoCast[player] = RegionEmpty();
//        g_BWDefilerDarkSwarmNoCastCount[player] = 1;
//    } else{ g_BWDefilerDarkSwarmNoCastCount[player] += 1; }
//    for (i = 0; i <= 10; i += 1) {
//        if(g_BWDefilerDarkSwarmNoCastTemp[player][i] == null){
//            index = i;
//            break;
//        }
//    }
//    if(index == -1){
//        return;
//    }
//    pos = EventPlayerEffectUsedPoint(c_effectLocationTargetPoint);
//    radius = AIEffectFixed(player, c_BWEF_DefilerSCBWDarkSwarm_Search, c_fieldAreaRadius0);
//    g_BWDefilerDarkSwarmNoCastTemp[player][index] = RegionCircle(pos, radius);
//    RegionAddCircle(g_BWDefilerDarkSwarmNoCast[player], true, pos, (radius + 0.5));
//    Wait((AIEffectFixed(player, "DefilerSCBWDarkSwarm@CP", c_fieldPeriodCount) * AIEffectFixed(player, "DefilerSCBWDarkSwarm@CP", "PeriodicPeriodArray[0]")), c_timeGame);
//    Wait(0.1, c_timeGame);
//    RegionAddCircle(g_BWDefilerDarkSwarmNoCast[player], false, pos, radius);
//    if(g_BWDefilerDarkSwarmNoCastCount[player] > 0){ g_BWDefilerDarkSwarmNoCastCount[player] -= 1; }
//    if(g_BWDefilerDarkSwarmNoCastCount[player] <= 0){ g_BWDefilerDarkSwarmNoCast[player] = null; }
//    if(index != -1){g_BWDefilerDarkSwarmNoCastTemp[player][index] = null;}
//    return;
//}
//
////--------------------------------------------------------------------------------------------------
//static order BWDefilerPlague (int player, unit aiUnit, unitgroup scanGroup, bool lowVitality, bool recentlyAttacked, marker mark) {
//	point loc;
//    unitgroup plagueGroup;
//    aifilter filter;
//	order ord;
//    fixed minScore;
//    int minHits;
//    int minDamage;
//
//    if (!AITactCooldownAllow(aiUnit, c_PlagueCooldown)) {
//        return null;
//    }
//
//    ord = AITacticalOrder(player, aiUnit, c_BWAB_DefilerSCBWPlague);
//	if (ord == null) {
//		return null;
//	}
//	
//    filter = AIFilter(player);
//    AISetFilterCanAttackAlly(filter, true, true);
//    AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_DefilerSCBWPlague_AB);
//    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
//    plagueGroup = AIGetFilterGroup(filter, scanGroup);
//
//    if (lowVitality) {
//        minScore = 0.5;
//        minHits = 3;
//        minDamage = 100;
//        if(recentlyAttacked){
//            minHits = 1;
//            minDamage = 50;
//        }
//    }
//    else {
//        minScore = 4.0;
//        minHits = 4;
//        minDamage = 300;
//    }
//
//	loc = AIBestTargetPoint(
//		AIEffectGroup(player, c_BWEF_DefilerSCBWPlague_Search, plagueGroup),
//		minHits,		// min hits
//		minDamage,	// base damage
//		minScore,	// score
//		AIEffectFixed(player, c_BWEF_DefilerSCBWPlague_Search, c_fieldAreaRadius0) + 0.6,
//		UnitGetPosition(aiUnit),
//		AIAbilityFixed(player, c_BWAB_DefilerSCBWPlague, c_fieldRange0),
//		c_unitAttributeNone
//	);
//	
//	if (loc == null) {
//		return null;
//	}
//	
//	OrderSetTargetPoint(ord, loc);
//	if (!UnitOrderIsValid(aiUnit,ord)) {
//		return null;
//	}
//	
//	return ord;
//}
//
//
//static bool BWPlagueCloakedAttacker (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
//    order ord;
//    point attacker;
//    point loc;
//    point aiPos;
//    string s;
//    unitgroup group;
//    aifilter filter;
//    if (!AITactCooldownAllow(aiUnit, c_PlagueCooldown)) {
//        return false;
//    }
//    ord = AICreateOrder(player, c_BWAB_DefilerSCBWPlague, 0);
//    if (!UnitOrderIsValid(aiUnit, ord)) {
//        return false;
//    }
//    aiPos = UnitGetPosition(aiUnit);
//    attacker = AIGetCloakedAttacker(player);
//    if(attacker != null){
//        if (DistanceBetweenPoints(aiPos, attacker) < AIAbilityFixed(player, c_BWAB_DefilerSCBWPlague, c_fieldRange0) + 3){
//            group = UnitGroupSearch(null, player, aiPos, AIAbilityFixed(player, c_BWAB_DefilerSCBWPlague, c_fieldRange0) + 3, UnitFilterStr("Enemy,Cloaked;Dead,Missile,Visible"), c_noMaxCount);
//            filter = AIFilter(player);
//            AISetFilterBehaviorCount(filter, c_noBehaviorMin, c_noBehaviorMax, c_BWBF_DefilerSCBWPlague_AB);
//            AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
//            group = AIGetFilterGroup(filter, group);
//
//            loc = AIBestTargetPoint(
//                AIEffectGroup(player, c_BWEF_DefilerSCBWPlague_Search, group),
//                1,		// min hits
//                1,	// base damage
//                1,	// score
//                AIEffectFixed(player, c_BWEF_DefilerSCBWPlague_Search, c_fieldAreaRadius0),
//                aiPos,
//                AIAbilityFixed(player, c_BWAB_DefilerSCBWPlague, c_fieldRange0) + 3,
//                c_unitAttributeNone
//            );
//            
//
//            if (loc == null) {
//                return false;
//            }
//
//            if(UnitGroupCount(group, c_unitCountAlive) > 0 && UnitGroupCount(AIFindUnits(player, c_ZU_Overlord, aiPos, 12, 1), c_unitCountAlive) == 0){
//                OrderSetTargetPoint(ord, loc);
//                if (UnitOrderIsValid(aiUnit, ord)) {
//		            mark = AIMarker(aiUnit, c_BWMK_DefilerSCBWPlague);
//                    AICastCooldown(aiUnit, ord, mark, c_castHold, c_PlagueCooldown, 4.5);
//                    AIClearCloakedAttacker(player, loc);
//                    return true;
//                }
//            }
//        }
//    }
//
//    return false;
//}
//
//static order BWDefilerMoveToSafety (int player, unit aiUnit, unitgroup scanGroup, bool wasRecentlyAttacked) {
//	order ord;
//    fixed bestDistance = 13;
//    int bestIndex = -1;
//    int bestCount = 1;
//    point loc;
//    unitgroup enemyUnits;
//    fixed dist;
//    int count;
//    int i;
//    aifilter filter;
//    point aiPos = UnitGetPosition(aiUnit);
//    // int pathingCost;
//
//    if(wasRecentlyAttacked){
//        bestCount = 10;
//    }
//
//    if(g_BWDefilerDarkSwarmNoCastCount[player] > 0){
//        filter = AIFilter(player);
//        AISetFilterAlliance(filter, c_playerGroupEnemy);
//        AISetFilterBits(filter, UnitFilterStr("Enemy,Visible;Dead,Hidden,Missile,Stasis,Passive"));
//        AISetFilterRange(filter, aiUnit, 12);
//        AISetFilterCanAttackAlly(filter, c_groundAlliesNearby, false);
//        enemyUnits = AIGetFilterGroup(filter, scanGroup);
//        if (UnitGroupCount(enemyUnits, c_unitCountAlive) > 0){
//            for (i = g_BWDefilerDarkSwarmNoCastCount[player] - 1; i >= 0; i -= 1) {
//                if(g_BWDefilerDarkSwarmNoCastTemp[player][i] != null){
//                    count = UnitGroupCount(UnitGroupFilterRegion(enemyUnits, g_BWDefilerDarkSwarmNoCastTemp[player][i], 10), c_unitCountAlive);
//                    loc = RegionGetCenter(g_BWDefilerDarkSwarmNoCastTemp[player][i]);
//                    dist = DistanceBetweenPoints(aiPos, loc);
//                    if(loc != null && PointPathingIsConnected(aiPos, loc) && dist < bestDistance){
//                        if(count < bestCount){
//                            bestCount = count;
//                            bestDistance = dist;
//                            bestIndex = i;
//                        }
//                    }
//                }
//            }
//        }
//        if (bestIndex == -1){ return null; }
//        loc = RegionGetCenter(g_BWDefilerDarkSwarmNoCastTemp[player][bestIndex]);
//        if(loc != null){
//            if(libNtve_gf_UnitInRegion(aiUnit, RegionCircle(loc, 1.0))){
//                ord = AICreateOrder(player, "stop", 0);
//            }else{
//                ord = AICreateOrder(player, "move", 0);
//                OrderSetTargetPoint(ord, loc);
//            }
//            return ord;
//        }
//    }
//
//    return null;
//}
//
////--------------------------------------------------------------------------------------------------
void AIThinkDefilerSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    marker mark;

    //Burrow Down
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
    
    ord = BWDefilerPlague(player, aiUnit, scanGroup, mark);
    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castRetreat);
        return;
    }

    ord = BWDarkSwarm(player, aiUnit, scanGroup);
    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castRetreat);
        return;
    }

    ord = BWDefilerConsume(player, aiUnit, scanGroup, mark);
    if (ord != null) {
        AICast(aiUnit, ord, c_noMarker, c_castHold);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** DRONE ***
//--------------------------------------------------------------------------------------------------
const int c_creepColonyBuildCooldown = c_tactTimerFirst;

order AIOrderCreepColonyBuild (int player, unit aiUnit) {
    order ord;
    point p;

    if (AIIsCampaign(player)) {
        return null;
    }

    if (!AITactCooldownAllow(aiUnit, c_creepColonyBuildCooldown)) {
        return null;
    }

    ord = AICreateOrder(player, "DroneSCBW@Build", 1);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    if (!AIHasRes(player,200,0)) {
        return null;
    }

    Wait(RandomFixed(0.0, 30.0), c_timeGame);

    // If any queued or in progress exist break
    if (AITechCount(player, c_BWZB_CreepColony, c_techCountQueuedOnly) > 0) {
        return null;
    }

    if (AITechCount(player, c_BWZB_CreepColony, c_techCountInProgressOnly) > 0) {
        return null;
    }

    // Make sure the player can afford to build at least one and have enough for other units
    if (!AIHasRes(player,200,0)) {
        return null;
    }

    ord = AICreateOrder(player, "DroneSCBW@Build", 1);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    //  Don't cast if there is no creep point set for this player.
    p = AIGetBestCreepSpot(player, aiUnit, 36);
    if (p == null) {
        return null;
    }

    OrderSetTargetPlacement(ord, p, aiUnit, c_BWZB_CreepColony);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}

//--------------------------------------------------------------------------------------------------
void AIThinkDroneSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    fixed cooldown;
    marker mark;

    //Burrow Down
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }

    ord = AIOrderCreepColonyBuild(player, aiUnit);
    if (ord != null) {
        if (!AIIsCampaign(player) && AIPlayerDifficulty(player) < c_campAdvanced) {
            cooldown = 180.0;
        }
        else {
            cooldown = 120.0;
        }
        AICastCooldown(aiUnit, ord, c_noMarker, c_castHold, c_creepColonyBuildCooldown, cooldown);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** HYDRALISK ***
//--------------------------------------------------------------------------------------------------
void AIThinkHydraliskSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Burrow Down
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** INFESTED TERRAN ***
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
order BWToggleSuicideBuilding (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    order ord;
    
    // Check UnitAbilityExists to prevent warnings in liberty
    if (!UnitAbilityExists(aiUnit, c_AB_VolatileBurstBuilding)) {
        return null;
    }

    // Simple logic, if we can turn off attacking buildings, then do so
    //
    ord = AICreateOrder(player, c_AB_VolatileBurstBuilding, 1);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    return ord;
}

//---------------------------------------------------------------------------------------------
void AIThinkInfestedTerranSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    marker mark;
    order ord;
    //Burrow
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
    
    // turn off automatically exploding on buildings
    ord = BWToggleSuicideBuilding(player, aiUnit, scanGroup, c_noMarker);
    if (ord != null) {
        AICast(aiUnit, ord, mark, c_castHold);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** LURKER ***
//--------------------------------------------------------------------------------------------------
void AIThinkLurkerSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Lurker Burrow/Unburrow
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** ULTRALISK ***
//--------------------------------------------------------------------------------------------------
void AIThinkUltraliskSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Burrow Down
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** ZERGLING ***
//--------------------------------------------------------------------------------------------------
void AIThinkZerglingSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Burrow Down
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** HATCHERY ***
//--------------------------------------------------------------------------------------------------
void AIThinkHatcherySCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Rallies
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** LAIR ***
//--------------------------------------------------------------------------------------------------
void AIThinkLairSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Rallies
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** HIVE ***
//--------------------------------------------------------------------------------------------------
void AIThinkHiveSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Rallies
    if (AIEvalTacticalData(aiUnit, null)) {
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** INFESTED COMMAND CENTER ***
//--------------------------------------------------------------------------------------------------
void AIThinkInfestedCommandCenterSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    //Rally
}

//--------------------------------------------------------------------------------------------------
//  BW Zerg Upgrade Buildings (Melee)
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  *** EVOLUTION CHAMBER ***
//--------------------------------------------------------------------------------------------------
void AIThinkEvolutionChamberSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    int meleeUnitCount;
    int rangedUnitCount;
    int groundUnitCount;

    if(AIIsCampaign(player)) {
        return;
    }

    // Only counts Combat Melee Units
    meleeUnitCount = 
    TechTreeUnitCount(player, c_BWZU_Zergling, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWZU_Ultralisk, c_techCountQueuedOrBetter);

    // Only counts Combat Ranged Units
    rangedUnitCount = 
    TechTreeUnitCount(player, c_BWZU_Hydralisk, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWZU_Lurker, c_techCountQueuedOrBetter);

    groundUnitCount = meleeUnitCount + rangedUnitCount;

    //Tier 1 Melee
    if(TechTreeUpgradeCount(player, c_BWZR_ZergMeleeAttacksSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergMeleeAttacksSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (meleeUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 1 Missile
    if(TechTreeUpgradeCount(player, c_BWZR_ZergMissileAttacksSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergMissileAttacksSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (rangedUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 1 Carapace
    if(TechTreeUpgradeCount(player, c_BWZR_ZergGroundCarapaceSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergGroundCarapaceSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 10) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Melee
    if(TechTreeUpgradeCount(player, c_BWZR_ZergMeleeAttacksSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergMeleeAttacksSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (meleeUnitCount >= 8) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Missile
    if(TechTreeUpgradeCount(player, c_BWZR_ZergMissileAttacksSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergMissileAttacksSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (rangedUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2 Carapace
    if(TechTreeUpgradeCount(player, c_BWZR_ZergGroundCarapaceSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergGroundCarapaceSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 10) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Melee
    if(TechTreeUpgradeCount(player, c_BWZR_ZergMeleeAttacksSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergMeleeAttacksSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (meleeUnitCount >= 10) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Missile
    if(TechTreeUpgradeCount(player, c_BWZR_ZergMissileAttacksSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergMissileAttacksSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (rangedUnitCount >= 6) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 3 Carapace
    if(TechTreeUpgradeCount(player, c_BWZR_ZergGroundCarapaceSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergGroundCarapaceSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (groundUnitCount >= 10) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  *** SPIRE ***
//--------------------------------------------------------------------------------------------------
void AIThinkSpireSCBW (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    int airUnitCount;

    if(AIIsCampaign(player)) {
        return;
    }

    // Only counts Combat Infantry Units
    airUnitCount = 
    TechTreeUnitCount(player, c_BWZU_Mutalisk, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWZU_Scourge, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWZU_Guardian, c_techCountQueuedOrBetter)+
    TechTreeUnitCount(player, c_BWZU_Devourer, c_techCountQueuedOrBetter);


    //Tier 1
    if(TechTreeUpgradeCount(player, c_BWZR_ZergFlyerAttacksSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergFlyerAttacksSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWZR_ZergFlyerCarapaceSCBW_Lvl1, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergFlyerCarapaceSCBW, 0);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 4) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2
    if(TechTreeUpgradeCount(player, c_BWZR_ZergFlyerAttacksSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergFlyerAttacksSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 8) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWZR_ZergFlyerCarapaceSCBW_Lvl2, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergFlyerCarapaceSCBW, 1);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 8) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    //Tier 2
    if(TechTreeUpgradeCount(player, c_BWZR_ZergFlyerAttacksSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergFlyerAttacksSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 12) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }

    if(TechTreeUpgradeCount(player, c_BWZR_ZergFlyerCarapaceSCBW_Lvl3, c_techCountQueuedOrBetter) == 0) {
        ord = AICreateOrder(player, c_BWZR_ZergFlyerCarapaceSCBW, 2);

        if (UnitOrderIsValid(aiUnit, ord)) {
            Wait(1.0, c_timeAI);
            if (airUnitCount >= 12) {
                if (UnitQueueItemTime(aiUnit,c_unitQueueTimeRemaining, 1) <= 0) {
                    AICast(aiUnit, ord, c_noMarker, c_castHold);
                }
            }
        }
    }
}